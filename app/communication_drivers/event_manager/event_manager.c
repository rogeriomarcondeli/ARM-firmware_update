/******************************************************************************
 * Copyright (C) 2018 by LNLS - Brazilian Synchrotron Light Laboratory
 *
 * Redistribution, modification or use of this software in source or binary
 * forms is permitted as long as the files maintain this copyright. LNLS and
 * the Brazilian Center for Research in Energy and Materials (CNPEM) are not
 * liable for any misuse of this material.
 *
 *****************************************************************************/

/**
 * @file event_manager.c
 * @brief Event manager module
 *
 * This module is responsible for the management of events during power supplies
 * operation, including data log on onboard memory. An event is generated by any
 * of the following situations:
 *
 *      1. Interlocks
 *      2. Alarms, in general caused by unusual operation values
 *      3. Commands received via communication interfaces, such as turn on/off,
 *         selection of operation mode, open/close control loop, changes on
 *         setpoint or other operation paramenters, etc. Usually is done by BSMP
 *         functions or HMI operation.
 *
 * Current version implements only interlocks management, including debouncing
 * logic (on C28).
 *
 * TODO: Events based on alarms and commands, and data log.
 * 
 * @author gabriel.brunheira
 * @date 23/11/2018
 *
 */

#include <stdint.h>
#include "communication_drivers/event_manager/event_manager.h"
#include "communication_drivers/ipc/ipc_lib.h"
#include "communication_drivers/ps_modules/ps_modules.h"

/**
 * Private variables
 */

/// Look-up-table to convert bit-position to bit mask
const static uint32_t lut_bit_position[32] =
{
    0x00000001, 0x00000002, 0x00000004, 0x00000008,
    0x00000010, 0x00000020, 0x00000040, 0x00000080,
    0x00000100, 0x00000200, 0x00000400, 0x00000800,
    0x00001000, 0x00002000, 0x00004000, 0x00008000,
    0x00010000, 0x00020000, 0x00040000, 0x00080000,
    0x00100000, 0x00200000, 0x00400000, 0x00800000,
    0x01000000, 0x02000000, 0x04000000, 0x08000000,
    0x10000000, 0x20000000, 0x40000000, 0x80000000
};

#pragma CODE_SECTION(set_hard_interlock, "ramfuncs");
#pragma CODE_SECTION(set_soft_interlock, "ramfuncs");

/**
 * Set specified hard interlock for specified module. First, check whether this
 * interlock has already been set. If not, inform C28 which module and interlock
 * and send interrupt request.
 *
 * @param id of event manager specific of a power supply/module
 * @param itlk specified hard interlock
 */
void set_hard_interlock(uint16_t id, uint32_t itlk)
{
    if(!(g_ipc_ctom.ps_module[id].ps_hard_interlock.u32 & lut_bit_position[itlk]))
    {
        g_ipc_mtoc.ps_module[id].ps_hard_interlock.u32 |= lut_bit_position[itlk];
        send_ipc_msg(id, HARD_INTERLOCK);
    }
}

/**
 * Set specified soft interlock for specified module. First, check whether this
 * interlock has already been set. If not, inform C28 which module and interlock
 * and send interrupt request.
 *
 * @param id id of event manager specific of a power supply/module
 * @param itlk specified soft interlock
 */
void set_soft_interlock(uint16_t id, uint32_t itlk)
{
    if(!(g_ipc_ctom.ps_module[id].ps_soft_interlock.u32 & lut_bit_position[itlk]))
    {
        g_ipc_mtoc.ps_module[id].ps_soft_interlock.u32 |= lut_bit_position[itlk];
        send_ipc_msg(id, SOFT_INTERLOCK);
    }
}
